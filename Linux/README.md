Linux 基础知识
====
## 知识列表
#### 零散知识点


#### IO复用的方法
select, poll, epoll都是IO多路复用的机制，所谓的IO多路复用机制就是通过一种机制可以见识多个描述符，一旦某个描述符就绪能通过程序进行相应的读写操作。
select和poll的实现机制类似，只是描述fd集合的方式不一样，poll使用pollfd，select使用fd_set；epoll算是select和poll的加强版。
select有三个缺点：
1. 每次调用select时需要将fd集合从用户态拷贝到内核态，开销大
2. select每次判断就绪都需要在内核态遍历所有传递进来的的fd，造成开销大
3. 支持的文件描述符少，默认为1024

epoll有epoll_create, epoll_ctl, epoll_wait可以避免select的缺点，描述如下：
1. epoll会在使用epoll_ctl注册事件时将fd拷贝到内核态，可以避免缺点一
2. epool在设备就绪时会将就绪的fd加入到就绪链表中，可以避免每次查询所有的fd

#### 高并发服务器的设计模式
###### 单进程服务，使用非阻塞io
使用一个进程服务多个客户，通常与客户通信的套接字设置为非阻塞的，阻塞只发生在select()、poll()、epoll_wait()等系统调用上面。缺点是无法利用对称多处理器的优势；select的描述符集个数有限制；会进行大量的系统调用。
###### 多进程服务，使用阻塞io
accept/fork 模型，每当有客户连线时产生一个新的进程为之服务，缺点是进程占用资源多，进程切换开销太大，进程信息共享麻烦。
###### 多线程服务，使用阻塞io
accept/pthread_create模型，有新客户来时创建一个服务线程而不是服务进程。这解决了多进程服务的一些问题，比如它占用资源少，信息共享方便。但是麻烦在于线程仍有可能消耗光，线程切换也需要开销。

#### 消息队列的实现机制，请求过多怎么处理？
消息队列可用在应用中以执行多种功能，比如要求服务、交换信息或异步处理等。中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。
**下面为个人理解：**
消息队列的实现可以转化为生产者-消费者模型，可以通过STL的dqueue + 信号量等实现，可以在消息中增加超时时间戳以应对请求过多的问题。
