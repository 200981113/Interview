STL题目
====
### 题目列表
##### STL中的stack为什么将pop和top分开，即pop的返回值为什么为void型？
+ 如果返回栈顶的值的话，会调用一次拷贝构造函数，这样效率会大打折扣，其次如果在调用拷贝构造函数的时候发生异常，则栈顶元素会丢失而且再也无法找回，因为已经成功弹出栈顶。
+ 如果返回的是栈顶的引用的话，则每次pop都会返回无效的引用

##### STL容器内部实现原理
###### vector
vector是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。vector分配的内存空间是以2的倍数动态增长的，将原先空间中的元素复制到新的空间中，性能消耗比较大。
clear函数只是把vector的size清为零，但vector中的元素在内存中并没有消除，所以在使用vector的过程中会发现内存消耗会越来越多，导致内存泄露.
###### deque
deque和vector类似，支持快速随机访问。二者最大的区别在于，vector只能在末端插入数据，而deque支持双端插入数据。deque的内存空间分布是小片的连续，小片间用链表相连，实际上内部有一个map的指针。deque空间的重新分配要比vector快，重新分配空间后，原有的元素是不需要拷贝的。
###### list
list是一个双向链表，因此它的内存空间是可以不连续的，通过指针来进行数据的访问，这使list的随机存储变得非常低效，因此list没有提供[]操作符的重载。但list可以很好地支持任意地方的插入和删除，只需移动相应的指针即可。
###### map
map是一种关联容器，map内部自建一棵红黑树，这棵树具有数据自动排序的功能，所以在map内部所有的数据都是有序的，以二叉树的形式进行组织.元素的value是可以改变的，但是key时不允许改变，只能删除后再添加。
###### set
set中的元素都是唯一的，而且默认情况下会对元素进行升序排列。所以在set中，不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，再插入新元素。不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存取。
###### stack/queque
stack/queue是在deque的基础上封装的。之所以选择deque而不选择vector是因为deque在删除元素的时候释放空间，同时在重新申请空间的时候无需拷贝所有元素

##### vector为何每次insert之后，以前保存的iterator不会失效`
+ iterator存储的是指向节点的指针，在vector删除和插入之后都可能造成对应节点的删除
+ **记住**：不要使用过时的iterator

##### hash_map和map的区别在哪里？
+ 构造函数：hash_map需要hash函数，等于函数；map只需要比较函数(小于函数)
+ 存储结构：hash_map采用hash表存储，map一般采用 红黑树(RB Tree) 实现

##### 描述一下红黑树特性
+ 红黑树节点中存储如下内容：父节点指针，左右节点指针，标识红黑节点的标志位，数据
+ 红黑树时平衡二叉树
+ 根节点和叶子节点都是黑树
+ 红树的子节点都是黑树
+ 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点


##### vector与array的区别
+ vector的大小时动态的，提供添加元素的函数；array的大小是固定的，必须在定义的时候指定，且不可以用非const变量初始化大小
+ 数组和vector不同，一个数组不能用另一个数组初始化，也不能将一个数组赋值给另一个数组